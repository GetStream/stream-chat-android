<?xml version='1.0' encoding='UTF-8'?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>ComplexMethod:ChannelLogic.kt$ChannelLogic$internal fun handleEvent(event: ChatEvent)</ID>
    <ID>ComplexMethod:CustomObjectFiltering.kt$@Suppress("UNCHECKED_CAST") internal fun &lt;T : CustomObject> FilterObject.filter(t: T): Boolean</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun equalsFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun greaterThanFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun greaterThanOrEqualsFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun inFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun lessThanFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun lessThanOrEqualsFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun notEqualsFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun notInFilterArguments()</ID>
    <ID>ComplexMethod:EventHandlerImpl.kt$EventHandlerImpl$private suspend fun updateOfflineStorageFromEvents(events: List&lt;ChatEvent>, isFromSync: Boolean)</ID>
    <ID>ComplexMethod:EventHandlerSequential.kt$EventHandlerSequential$private suspend fun updateGlobalState(batchEvent: BatchEvent)</ID>
    <ID>ComplexMethod:EventHandlerSequential.kt$EventHandlerSequential$private suspend fun updateOfflineStorage(batchEvent: BatchEvent)</ID>
    <ID>EmptyFunctionBlock:EventHandlerImpl.kt$EventHandlerImpl.Companion.&lt;no name provided>${}</ID>
    <ID>ForbiddenComment:ChatClientStateCalls.kt$ChatClientStateCalls$// todo: Fix this!!</ID>
    <ID>ForbiddenComment:EventBatchUpdate.kt$EventBatchUpdate$// TODO: this overwrites members which in the case when you have > 100 members isn't the right behaviour</ID>
    <ID>ForbiddenComment:SendMessageInterceptorImpl.kt$SendMessageInterceptorImpl$// TODO: an event broadcasting feature for LOCAL/offline events on the LLC would be a cleaner approach</ID>
    <ID>LargeClass:CustomObjectFilteringTest.kt$CustomObjectFilteringTest$Companion</ID>
    <ID>LongMethod:ChannelLogic.kt$ChannelLogic$internal fun handleEvent(event: ChatEvent)</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun distinctFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun equalsFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun greaterThanFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun greaterThanOrEqualsFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun inFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun lessThanFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun lessThanOrEqualsFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun notEqualsFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun notInFilterArguments()</ID>
    <ID>LongMethod:EventHandlerImpl.kt$EventHandlerImpl$private suspend fun updateOfflineStorageFromEvents(events: List&lt;ChatEvent>, isFromSync: Boolean)</ID>
    <ID>LongMethod:EventHandlerSequential.kt$EventHandlerSequential$private suspend fun updateGlobalState(batchEvent: BatchEvent)</ID>
    <ID>LongMethod:EventHandlerSequential.kt$EventHandlerSequential$private suspend fun updateOfflineStorage(batchEvent: BatchEvent)</ID>
    <ID>LongMethod:QueryChannelsSortTest.kt$QueryChannelsSortTest.Companion$@JvmStatic fun hasUnreadSortArguments()</ID>
    <ID>LongParameterList:AttachmentUploader.kt$AttachmentUploader$( channelType: String, channelId: String, file: File, progressCallback: ProgressCallback?, attachment: Attachment, mimeType: String, attachmentType: AttachmentType, )</ID>
    <ID>LoopWithTooManyJumpStatements:EventHandlerSequential.kt$EventHandlerSequential$for (event in events) { when (event) { is ConnectedEvent -> if (batchEvent.isFromSocketConnection) { event.me.id mustBe currentUserId repos.insertCurrentUser(event.me) } // keep the data in Room updated based on the various events.. // note that many of these events should also update user information is NewMessageEvent -> { event.message.enrichWithCid(event.cid) event.message.enrichWithOwnReactions(batch, currentUserId, event.user) batch.addMessageData(event.cid, event.message, isNewMessage = true) // first check channel in batch, if not found, check in db // if we ignore batch, we may override existing channel in batch with the one from db val channel = batch.getCurrentChannel(event.cid) ?: repos.selectChannelWithoutMessages(event.cid) ?: continue val updatedChannel = channel.copy( hidden = false, messages = listOf(event.message) ) batch.addChannel(updatedChannel) } is MessageDeletedEvent -> { event.message.enrichWithCid(event.cid) event.message.enrichWithOwnReactions(batch, currentUserId, event.user) batch.addMessageData(event.cid, event.message) } is MessageUpdatedEvent -> { event.message.enrichWithCid(event.cid) event.message.enrichWithOwnReactions(batch, currentUserId, event.user) batch.addMessageData(event.cid, event.message) } is NotificationMessageNewEvent -> { event.message.enrichWithCid(event.cid) batch.addMessageData(event.cid, event.message, isNewMessage = true) val channel = batch.getCurrentChannel(event.cid) ?.mergeChannelFromEvent(event.channel) ?: event.channel batch.addChannel(channel.copy(hidden = false)) } is NotificationAddedToChannelEvent -> { val channel = batch.getCurrentChannel(event.cid) ?.mergeChannelFromEvent(event.channel) ?: event.channel batch.addChannel( channel.addMembership(currentUserId, event.member) ) } is NotificationInvitedEvent -> { batch.addUser(event.user) batch.addUser(event.member.user) } is NotificationInviteAcceptedEvent -> { val channel = batch.getCurrentChannel(event.cid) ?.mergeChannelFromEvent(event.channel) ?: event.channel batch.addUser(event.user) batch.addUser(event.member.user) batch.addChannel(channel) } is NotificationInviteRejectedEvent -> { val channel = batch.getCurrentChannel(event.cid) ?.mergeChannelFromEvent(event.channel) ?: event.channel batch.addUser(event.user) batch.addUser(event.member.user) batch.addChannel(channel) } is ChannelHiddenEvent -> { batch.getCurrentChannel(event.cid)?.let { val updatedChannel = it.apply { hidden = true hiddenMessagesBefore = event.createdAt.takeIf { event.clearHistory } } batch.addChannel(updatedChannel) } } is ChannelVisibleEvent -> { batch.getCurrentChannel(event.cid)?.let { batch.addChannel(it.apply { hidden = false }) } } is NotificationMutesUpdatedEvent -> { event.me.id mustBe currentUserId repos.insertCurrentUser(event.me) } is ReactionNewEvent -> { event.message.enrichWithCid(event.cid) event.message.enrichWithOwnReactions(batch, currentUserId, event.user) batch.addMessage(event.message) } is ReactionDeletedEvent -> { event.message.enrichWithCid(event.cid) event.message.enrichWithOwnReactions(batch, currentUserId, event.user) batch.addMessage(event.message) } is ReactionUpdateEvent -> { event.message.enrichWithCid(event.cid) event.message.enrichWithOwnReactions(batch, currentUserId, event.user) batch.addMessage(event.message) } is ChannelUserBannedEvent -> { batch.getCurrentChannel(event.cid)?.let { channel -> batch.addChannel( channel.updateMemberBanned(event.user.id, banned = true, event.shadow) .updateMembershipBanned(event.user.id, banned = true) ) } } is ChannelUserUnbannedEvent -> { batch.getCurrentChannel(event.cid)?.let { channel -> batch.addChannel( channel.updateMemberBanned(event.user.id, banned = false, false) .updateMembershipBanned(event.user.id, banned = false) ) } } is MemberAddedEvent -> { batch.getCurrentChannel(event.cid)?.let { channel -> batch.addChannel( channel.addMember(event.member) ) } } is MemberUpdatedEvent -> { batch.getCurrentChannel(event.cid)?.let { channel -> batch.addChannel( channel.updateMember(event.member) .updateMembership(event.member) ) } } is MemberRemovedEvent -> { if (event.user.id == currentUserId) { logger.i { "[updateOfflineStorage] skip MemberRemovedEvent for currentUser" } continue } batch.getCurrentChannel(event.cid)?.let { channel -> batch.addChannel( channel.removeMember(event.user.id) .removeMembership(currentUserId) ) } } is NotificationRemovedFromChannelEvent -> { batch.getCurrentChannel(event.cid)?.let { channel -> batch.addChannel( channel.removeMembership(currentUserId).apply { memberCount = event.channel.memberCount members = event.channel.members watcherCount = event.channel.watcherCount watchers = event.channel.watchers } ) } } is ChannelUpdatedEvent -> { val channel = batch.getCurrentChannel(event.cid) ?.mergeChannelFromEvent(event.channel) ?: event.channel batch.addChannel(channel) } is ChannelUpdatedByUserEvent -> { val channel = batch.getCurrentChannel(event.cid) ?.mergeChannelFromEvent(event.channel) ?: event.channel batch.addChannel(channel) } is ChannelDeletedEvent -> { val channel = batch.getCurrentChannel(event.cid) ?.mergeChannelFromEvent(event.channel) ?: event.channel batch.addChannel(channel) } is ChannelTruncatedEvent -> { val channel = batch.getCurrentChannel(event.cid) ?.mergeChannelFromEvent(event.channel) ?: event.channel batch.addChannel(channel) } is NotificationChannelDeletedEvent -> { val channel = batch.getCurrentChannel(event.cid) ?.mergeChannelFromEvent(event.channel) ?: event.channel batch.addChannel(channel) } is NotificationChannelMutesUpdatedEvent -> { event.me.id mustBe currentUserId repos.insertCurrentUser(event.me) } is NotificationChannelTruncatedEvent -> { val channel = batch.getCurrentChannel(event.cid) ?.mergeChannelFromEvent(event.channel) ?: event.channel batch.addChannel(channel) } // get the channel, update reads, write the channel is MessageReadEvent -> batch.getCurrentChannel(event.cid) ?.apply { updateReads(ChannelUserRead(user = event.user, lastRead = event.createdAt)) } ?.let(batch::addChannel) is NotificationMarkReadEvent -> { batch.getCurrentChannel(event.cid) ?.apply { updateReads(ChannelUserRead(user = event.user, lastRead = event.createdAt)) } ?.let(batch::addChannel) } is GlobalUserBannedEvent -> { batch.addUser(event.user.apply { banned = true }) } is GlobalUserUnbannedEvent -> { batch.addUser(event.user.apply { banned = false }) } is UserUpdatedEvent -> if (event.user.id == currentUserId) { repos.insertCurrentUser(event.user) } else -> Unit } }</ID>
    <ID>MagicNumber:QueryChannelPaginationRequest.kt$QueryChannelPaginationRequest$30</ID>
    <ID>MagicNumber:SyncManager.kt$SyncManager$30</ID>
    <ID>MatchingDeclarationName:OfflineErrorHandlerFactories.kt$OfflineErrorHandlerFactoriesProvider</ID>
    <ID>MaxLineLength:ChannelLogic.kt$ChannelLogic$*</ID>
    <ID>MaxLineLength:ChannelsStateData.kt$ChannelsStateData.OfflineNoResults$/** If we are offline and don't have channels stored in offline storage, typically displayed as an error condition. */</ID>
    <ID>MaxLineLength:ChatClient.kt$*</ID>
    <ID>MaxLineLength:CustomObjectFiltering.kt$compare(t.getMemberPropertyOrExtra(fieldName, value::class) as? Comparable&lt;Any>, value as? Comparable&lt;Any>) { it &lt; 0 }</ID>
    <ID>MaxLineLength:CustomObjectFiltering.kt$compare(t.getMemberPropertyOrExtra(fieldName, value::class) as? Comparable&lt;Any>, value as? Comparable&lt;Any>) { it &lt;= 0 }</ID>
    <ID>MaxLineLength:CustomObjectFiltering.kt$compare(t.getMemberPropertyOrExtra(fieldName, value::class) as? Comparable&lt;Any>, value as? Comparable&lt;Any>) { it > 0 }</ID>
    <ID>MaxLineLength:CustomObjectFiltering.kt$compare(t.getMemberPropertyOrExtra(fieldName, value::class) as? Comparable&lt;Any>, value as? Comparable&lt;Any>) { it >= 0 }</ID>
    <ID>MaxLineLength:CustomObjectFiltering.kt$getMemberPropertyOrExtra(MEMBERS_FIELD_NAME, List::class)?.mapNotNull { (it as? Member)?.getUserId() } ?: emptyList()</ID>
    <ID>MaxLineLength:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$(expectedList + List(10) { randomChannel(members = List(positiveRandomInt(10)) { randomMember() }) }).shuffled()</ID>
    <ID>MaxLineLength:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$List(positiveRandomInt(10)) { randomChannel(type = randomString(20) + stringQuery + randomString(20)) }</ID>
    <ID>MaxLineLength:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$members = (List(positiveRandomInt(10)) { randomMember() } + members).shuffled()</ID>
    <ID>MaxLineLength:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$randomChannel(members = (List(positiveRandomInt(10)) { randomMember() } + randomMember(randomUser(id = memberId))).shuffled())</ID>
    <ID>MaxLineLength:DeleteReactionErrorHandlerImpl.kt$DeleteReactionErrorHandlerImpl$*</ID>
    <ID>MaxLineLength:EventHandlerImpl.kt$EventHandlerImpl$"Skipping unread counts update for channel: $cid. ${ChannelCapabilities.READ_EVENTS} capability is missing."</ID>
    <ID>MaxLineLength:EventHandlerImpl.kt$EventHandlerImpl$*</ID>
    <ID>MaxLineLength:EventHandlerSequential.kt$EventHandlerSequential$"Skipping unread counts update for channel: $cid. ${ChannelCapabilities.READ_EVENTS} capability is missing."</ID>
    <ID>MaxLineLength:EventHandlerSequential.kt$EventHandlerSequential$logger.v { "[updateChannelsState] batchId: ${batchEvent.id}, batchEvent.size: ${batchEvent.size}, first(${first?.seq}) &lt; last(${last?.seq}): $firstLessLast" }</ID>
    <ID>MaxLineLength:Mapper.kt$internal</ID>
    <ID>MaxLineLength:QueryChannelsSortTest.kt$QueryChannelsSortTest.Companion$testName = "Sorting by unreadCount field reference in descending order and by memberCount field reference in ascending order"</ID>
    <ID>MaxLineLength:QueryChannelsSortTest.kt$QueryChannelsSortTest.Companion$testName = "Sorting by unread_count field name in descending order and by name extra data field in ascending order"</ID>
    <ID>MaxLineLength:SendReactionErrorHandlerImpl.kt$SendReactionErrorHandlerImpl$*</ID>
    <ID>MaxLineLength:SocketEventCollector.kt$SocketEventCollector$*</ID>
    <ID>MaxLineLength:StatePlugin.kt$StatePlugin$*</ID>
    <ID>MaxLineLength:StatePluginConfig.kt$StatePluginConfig$*</ID>
    <ID>MaxLineLength:SyncManager.kt$SyncManager$*</ID>
    <ID>MaxLineLength:ThreadState.kt$ThreadState$/** The oldest message available in this thread state. It's null when we haven't loaded any messages in thread yet. */</ID>
    <ID>NestedBlockDepth:CustomObjectFiltering.kt$@Suppress("UNCHECKED_CAST") internal fun &lt;T : CustomObject> FilterObject.filter(t: T): Boolean</ID>
    <ID>NestedBlockDepth:EventHandlerImpl.kt$EventHandlerImpl$private suspend fun updateOfflineStorageFromEvents(events: List&lt;ChatEvent>, isFromSync: Boolean)</ID>
    <ID>NestedBlockDepth:EventHandlerSequential.kt$EventHandlerSequential$private suspend fun updateGlobalState(batchEvent: BatchEvent)</ID>
    <ID>NestedBlockDepth:EventHandlerSequential.kt$EventHandlerSequential$private suspend fun updateOfflineStorage(batchEvent: BatchEvent)</ID>
    <ID>ReturnCount:SyncManager.kt$SyncManager$@VisibleForTesting internal suspend fun performSync(cids: List&lt;String>)</ID>
    <ID>SwallowedException:CustomObjectFiltering.kt$e: ClassCastException</ID>
    <ID>TooGenericExceptionCaught:ChatClient.kt$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:EventHandlerSequential.kt$EventHandlerSequential$e: Throwable</ID>
    <ID>UnusedPrivateMember:ChannelLogic.kt$ChannelLogic$private fun upsertEventMessages(messages: List&lt;Message>)</ID>
    <ID>UnusedPrivateMember:EventBatchUpdate.kt$EventBatchUpdate$private suspend fun enrichChannelsWithCapabilities()</ID>
    <ID>UnusedPrivateMember:QueryChannelsSortTest.kt$QueryChannelsSortTest$testName: String</ID>
    <ID>UnusedPrivateMember:ThreadLogic.kt$ThreadLogic$private fun handleEvent(event: HasMessage)</ID>
    <ID>UnusedPrivateMember:UploadAttachmentsIntegrationTests.kt$UploadAttachmentsIntegrationTests$private val currentUser = randomUser()</ID>
  </CurrentIssues>
</SmellBaseline>
