<?xml version='1.0' encoding='UTF-8'?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>ComplexMethod:ChannelLogic.kt$ChannelLogic$ internal fun handleEvent(event: ChatEvent)</ID>
    <ID>ComplexMethod:CustomObjectFiltering.kt$@Suppress("UNCHECKED_CAST") internal fun &lt;T : CustomObject> FilterObject.filter(t: T): Boolean</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun equalsFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun greaterThanFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun greaterThanOrEqualsFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun inFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun lessThanFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun lessThanOrEqualsFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun notEqualsFilterArguments()</ID>
    <ID>ComplexMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun notInFilterArguments()</ID>
    <ID>ComplexMethod:EventHandlerImpl.kt$EventHandlerImpl$private suspend fun updateOfflineStorageFromEvents(events: List&lt;ChatEvent>, isFromSync: Boolean)</ID>
    <ID>ComplexMethod:FilterObjectConverter.kt$private fun FilterObject.toMap(): Map&lt;String, Any></ID>
    <ID>ComplexMethod:FilterObjectConverter.kt$private fun Map.Entry&lt;String, Any>.toFilterObject(): FilterObject</ID>
    <ID>ComplexMethod:FilterObjectConverterTest.kt$FilterObjectConverterTest.Companion$@JvmStatic fun objectToStringArguments()</ID>
    <ID>ComplexMethod:FilterObjectConverterTest.kt$FilterObjectConverterTest.Companion$@JvmStatic fun stringToObjectArguments()</ID>
    <ID>ComplexMethod:PaginationTest.kt$PaginationTest.Companion$@JvmStatic fun createPaginationInput()</ID>
    <ID>EmptyFunctionBlock:BaseDomainTest2.kt$BaseDomainTest2.&lt;no name provided>${}</ID>
    <ID>EmptyFunctionBlock:EventHandlerImpl.kt$EventHandlerImpl.Companion.&lt;no name provided>${}</ID>
    <ID>ForbiddenComment:BaseDomainTest2.kt$BaseDomainTest2$// TODO: a chat domain without a user set should raise a clear error</ID>
    <ID>ForbiddenComment:ChatClientStateCalls.kt$ChatClientStateCalls$// todo: Fix this!!</ID>
    <ID>ForbiddenComment:EventBatchUpdate.kt$EventBatchUpdate$// TODO: this overwrites members which in the case when you have > 100 members isn't the right behaviour</ID>
    <ID>ForbiddenComment:MessageUtils.kt$// TODO: type should be a sealed/class or enum at the client level</ID>
    <ID>ForbiddenComment:SendMessageInterceptorImpl.kt$SendMessageInterceptorImpl$// TODO: an event broadcasting feature for LOCAL/offline events on the LLC would be a cleaner approach</ID>
    <ID>LargeClass:CustomObjectFilteringTest.kt$CustomObjectFilteringTest$Companion</ID>
    <ID>LongMethod:ChannelLogic.kt$ChannelLogic$ internal fun handleEvent(event: ChatEvent)</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun distinctFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun equalsFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun greaterThanFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun greaterThanOrEqualsFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun inFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun lessThanFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun lessThanOrEqualsFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun notEqualsFilterArguments()</ID>
    <ID>LongMethod:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$@JvmStatic fun notInFilterArguments()</ID>
    <ID>LongMethod:EventHandlerImpl.kt$EventHandlerImpl$private suspend fun updateOfflineStorageFromEvents(events: List&lt;ChatEvent>, isFromSync: Boolean)</ID>
    <ID>LongMethod:FilterObjectConverterTest.kt$FilterObjectConverterTest.Companion$@JvmStatic fun objectToStringArguments()</ID>
    <ID>LongMethod:FilterObjectConverterTest.kt$FilterObjectConverterTest.Companion$@JvmStatic fun stringToObjectArguments()</ID>
    <ID>LongMethod:PaginationTest.kt$PaginationTest.Companion$@JvmStatic fun createPaginationInput()</ID>
    <ID>LongMethod:QueryChannelsSortTest.kt$QueryChannelsSortTest.Companion$@JvmStatic fun hasUnreadSortArguments()</ID>
    <ID>LongMethod:StreamOfflinePluginFactory.kt$StreamOfflinePluginFactory$ private fun createOfflinePlugin(user: User): OfflinePlugin</ID>
    <ID>LongParameterList:EventHandlerImpl.kt$EventHandlerImpl$( private val recoveryEnabled: Boolean, private val client: ChatClient, private val logic: LogicRegistry, private val state: StateRegistry, private val mutableGlobalState: GlobalMutableState, private val repos: RepositoryFacade, private val syncManager: SyncManager, )</ID>
    <ID>LongParameterList:OfflinePlugin.kt$OfflinePlugin$( private val queryChannelsListener: QueryChannelsListener, private val queryChannelListener: QueryChannelListener, private val threadQueryListener: ThreadQueryListener, private val channelMarkReadListener: ChannelMarkReadListener, private val editMessageListener: EditMessageListener, private val hideChannelListener: HideChannelListener, private val markAllReadListener: MarkAllReadListener, private val deleteReactionListener: DeleteReactionListener, private val sendReactionListener: SendReactionListener, private val deleteMessageListener: DeleteMessageListener, private val sendGiphyListener: SendGiphyListener, private val shuffleGiphyListener: ShuffleGiphyListener, private val sendMessageListener: SendMessageListener, private val queryMembersListener: QueryMembersListener, private val typingEventListener: TypingEventListener, private val createChannelListener: CreateChannelListener, )</ID>
    <ID>LongParameterList:RepositoryFacade.kt$RepositoryFacade$( userRepository: UserRepository, configsRepository: ChannelConfigRepository, private val channelsRepository: ChannelRepository, queryChannelsRepository: QueryChannelsRepository, private val messageRepository: MessageRepository, private val reactionsRepository: ReactionRepository, syncStateRepository: SyncStateRepository, attachmentRepository: AttachmentRepository, private val scope: CoroutineScope, private val defaultConfig: Config, )</ID>
    <ID>LongParameterList:SendMessageInterceptorImpl.kt$SendMessageInterceptorImpl$( private val context: Context, private val logic: LogicRegistry, private val globalState: GlobalState, private val channelRepository: ChannelRepository, private val messageRepository: MessageRepository, private val attachmentRepository: AttachmentRepository, private val scope: CoroutineScope, private val networkType: UploadAttachmentsNetworkType, )</ID>
    <ID>MagicNumber:QueryChannelPaginationRequest.kt$QueryChannelPaginationRequest$30</ID>
    <ID>MagicNumber:RepositoryFactory.kt$RepositoryFactory$100</ID>
    <ID>MagicNumber:SyncManager.kt$SyncManager$30</ID>
    <ID>MagicNumber:TypingEventListenerImpl.kt$TypingEventListenerImpl$3000</ID>
    <ID>MatchingDeclarationName:OfflineErrorHandlerFactories.kt$OfflineErrorHandlerFactoriesProvider</ID>
    <ID>MaxLineLength:ChannelDao.kt$ChannelDao$@Query("UPDATE stream_chat_channel_state SET hidden = :hidden, hideMessagesBefore = :hideMessagesBefore WHERE cid = :cid")</ID>
    <ID>MaxLineLength:ChannelData.kt$ChannelData$*</ID>
    <ID>MaxLineLength:ChannelEntity.kt$ChannelEntity$*</ID>
    <ID>MaxLineLength:ChannelLogic.kt$ChannelLogic$*</ID>
    <ID>MaxLineLength:ChannelLogic.kt$ChannelLogic$logger.logW("Permanent failure calling channel.watch for channel ${mutableState.cid}, with error $error")</ID>
    <ID>MaxLineLength:ChannelLogic.kt$ChannelLogic$logger.logW("Temporary failure calling channel.watch for channel ${mutableState.cid}. Marking the channel as needing recovery. Error was $error")</ID>
    <ID>MaxLineLength:ChannelMarkReadHelper.kt$ChannelMarkReadHelper$channelState.lastMarkReadEvent == null || lastMessageDate?.after(channelState.lastMarkReadEvent) == true</ID>
    <ID>MaxLineLength:ChannelMarkReadHelper.kt$ChannelMarkReadHelper$logger.logI("Last message date [$lastMessageDate] is not after last read event [${channelState.lastMarkReadEvent}]; no need to update.")</ID>
    <ID>MaxLineLength:ChannelsStateData.kt$ChannelsStateData.OfflineNoResults$/** If we are offline and don't have channels stored in offline storage, typically displayed as an error condition. */</ID>
    <ID>MaxLineLength:ChatClient.kt$*</ID>
    <ID>MaxLineLength:ChatEventHandler.kt$ChatEventHandler$*</ID>
    <ID>MaxLineLength:Config.kt$Config$*</ID>
    <ID>MaxLineLength:CreateChannelListenerImpl.kt$CreateChannelListenerImpl$*</ID>
    <ID>MaxLineLength:CustomObjectFiltering.kt$compare(t.getMemberPropertyOrExtra(fieldName, value::class) as? Comparable&lt;Any>, value as? Comparable&lt;Any>) { it &lt; 0 }</ID>
    <ID>MaxLineLength:CustomObjectFiltering.kt$compare(t.getMemberPropertyOrExtra(fieldName, value::class) as? Comparable&lt;Any>, value as? Comparable&lt;Any>) { it &lt;= 0 }</ID>
    <ID>MaxLineLength:CustomObjectFiltering.kt$compare(t.getMemberPropertyOrExtra(fieldName, value::class) as? Comparable&lt;Any>, value as? Comparable&lt;Any>) { it > 0 }</ID>
    <ID>MaxLineLength:CustomObjectFiltering.kt$compare(t.getMemberPropertyOrExtra(fieldName, value::class) as? Comparable&lt;Any>, value as? Comparable&lt;Any>) { it >= 0 }</ID>
    <ID>MaxLineLength:CustomObjectFiltering.kt$getMemberPropertyOrExtra(MEMBERS_FIELD_NAME, List::class)?.mapNotNull { (it as? Member)?.getUserId() } ?: emptyList()</ID>
    <ID>MaxLineLength:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$(expectedList + List(10) { randomChannel(members = List(positiveRandomInt(10)) { randomMember() }) }).shuffled()</ID>
    <ID>MaxLineLength:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$List(positiveRandomInt(10)) { randomChannel(type = randomString(20) + stringQuery + randomString(20)) }</ID>
    <ID>MaxLineLength:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$members = (List(positiveRandomInt(10)) { randomMember() } + members).shuffled()</ID>
    <ID>MaxLineLength:CustomObjectFilteringTest.kt$CustomObjectFilteringTest.Companion$randomChannel(members = (List(positiveRandomInt(10)) { randomMember() } + randomMember(randomUser(id = memberId))).shuffled())</ID>
    <ID>MaxLineLength:DefaultInterceptor.kt$DefaultInterceptor$*</ID>
    <ID>MaxLineLength:DeleteMessageListenerImpl.kt$DeleteMessageListenerImpl$*</ID>
    <ID>MaxLineLength:DeleteReactionErrorHandlerImpl.kt$DeleteReactionErrorHandlerImpl$*</ID>
    <ID>MaxLineLength:EventHandlerImpl.kt$EventHandlerImpl$*</ID>
    <ID>MaxLineLength:EventHandlerImpl.kt$EventHandlerImpl$logger.logD("Skipping unread counts update for channel: $cid. ${ChannelCapabilities.READ_EVENTS} capability is missing.")</ID>
    <ID>MaxLineLength:EventHandlerImpl.kt$EventHandlerImpl$throw InputMismatchException("received connect event for user with id ${me.id} while for user configured has id ${currentUser?.id}. Looks like there's a problem in the user set")</ID>
    <ID>MaxLineLength:EventHandlerProvider.kt$EventHandlerProvider$get() = _eventHandler ?: throw IllegalStateException("EventHandlerImpl was not set in the EventHandlerProvider. Looks like there's a initialisation problem")</ID>
    <ID>MaxLineLength:FilterObjectConverter.kt$this.size == 2 &amp;&amp; this.containsKey(KEY_DISTINCT) &amp;&amp; this.containsKey(KEY_MEMBERS) -> Filters.distinct((this[KEY_MEMBERS] as List&lt;String>))</ID>
    <ID>MaxLineLength:FilterObjectConverterTest.kt$FilterObjectConverterTest.Companion$"{\"\$and\":[{\"$fieldName\":{\"\$in\":[${values.joinToString(separator = ",")}]}},{\"$fieldName\":{\"\$eq\":${values.first()}}}]}"</ID>
    <ID>MaxLineLength:FilterObjectConverterTest.kt$FilterObjectConverterTest.Companion$"{\"\$nor\":[{\"$fieldName\":{\"\$in\":[${values.joinToString(separator = ",")}]}},{\"$fieldName\":{\"\$eq\":${values.first()}}}]}"</ID>
    <ID>MaxLineLength:FilterObjectConverterTest.kt$FilterObjectConverterTest.Companion$"{\"\$or\":[{\"$fieldName\":{\"\$in\":[${values.joinToString(separator = ",")}]}},{\"$fieldName\":{\"\$eq\":${values.first()}}}]}"</ID>
    <ID>MaxLineLength:GlobalMutableState.kt$GlobalMutableState.Companion$*</ID>
    <ID>MaxLineLength:Mapper.kt$internal</ID>
    <ID>MaxLineLength:Message.kt$*</ID>
    <ID>MaxLineLength:MessageDao.kt$MessageDao$@Query("SELECT * FROM stream_chat_message WHERE stream_chat_message.syncStatus IN (:syncStatus) ORDER BY CASE WHEN createdAt IS NULL THEN createdLocallyAt ELSE createdAt END ASC")</ID>
    <ID>MaxLineLength:MessageDao.kt$MessageDao$@Query("SELECT * from stream_chat_message WHERE cid = :cid AND (createdAt &lt; :dateFilter || createdLocallyAt &lt; :dateFilter) ORDER BY CASE WHEN createdAt IS NULL THEN createdLocallyAt ELSE createdAt END DESC LIMIT :limit")</ID>
    <ID>MaxLineLength:MessageDao.kt$MessageDao$@Query("SELECT * from stream_chat_message WHERE cid = :cid AND (createdAt &lt;= :dateFilter || createdLocallyAt &lt;= :dateFilter) ORDER BY CASE WHEN createdAt IS NULL THEN createdLocallyAt ELSE createdAt END DESC LIMIT :limit")</ID>
    <ID>MaxLineLength:MessageDao.kt$MessageDao$@Query("SELECT * from stream_chat_message WHERE cid = :cid AND (createdAt > :dateFilter || createdLocallyAt > :dateFilter) ORDER BY CASE WHEN createdAt IS NULL THEN createdLocallyAt ELSE createdAt END ASC LIMIT :limit")</ID>
    <ID>MaxLineLength:MessageDao.kt$MessageDao$@Query("SELECT * from stream_chat_message WHERE cid = :cid AND (createdAt >= :dateFilter || createdLocallyAt >= :dateFilter) ORDER BY CASE WHEN createdAt IS NULL THEN createdLocallyAt ELSE createdAt END ASC LIMIT :limit")</ID>
    <ID>MaxLineLength:MessageDao.kt$MessageDao$@Query("SELECT * from stream_chat_message WHERE cid = :cid ORDER BY CASE WHEN createdAt IS NULL THEN createdLocallyAt ELSE createdAt END DESC LIMIT :limit")</ID>
    <ID>MaxLineLength:MessageDao.kt$MessageDao$protected</ID>
    <ID>MaxLineLength:MessageEntity.kt$MessageInnerEntity$@Entity(tableName = "stream_chat_message", indices = [Index(value = ["cid", "createdAt"]), Index(value = ["syncStatus"])])</ID>
    <ID>MaxLineLength:MessagesState.kt$MessagesState.OfflineNoResults$/** If we are offline and don't have channels stored in offline storage, typically displayed as an error condition. */</ID>
    <ID>MaxLineLength:NonMemberChatEventHandler.kt$NonMemberChatEventHandler$*</ID>
    <ID>MaxLineLength:OfflinePlugin.kt$OfflinePlugin$*</ID>
    <ID>MaxLineLength:QueryChannelsLogic.kt$QueryChannelsLogic$*</ID>
    <ID>MaxLineLength:QueryChannelsLogic.kt$QueryChannelsLogic$logger.logI("storeStateForChannels stored ${channelsResponse.size} channels, ${configs.size} configs, ${users.size} users and ${messages.size} messages")</ID>
    <ID>MaxLineLength:QueryChannelsLogic.kt$QueryChannelsLogic$when</ID>
    <ID>MaxLineLength:QueryChannelsSortTest.kt$QueryChannelsSortTest.Companion$testName = "Sorting by unreadCount field reference in descending order and by memberCount field reference in ascending order"</ID>
    <ID>MaxLineLength:QueryChannelsSortTest.kt$QueryChannelsSortTest.Companion$testName = "Sorting by unread_count field name in descending order and by name extra data field in ascending order"</ID>
    <ID>MaxLineLength:QuerySortConverter.kt$QuerySortConverter$val direction = (sortSpecMap[QuerySort.KEY_DIRECTION] as? Number)?.toInt() ?: error("Cannot parse sortSpec to query sort\n$sortSpecMap")</ID>
    <ID>MaxLineLength:QuerySortConverter.kt$QuerySortConverter$val fieldName = sortSpecMap[QuerySort.KEY_FIELD_NAME] as? String ?: error("Cannot parse sortSpec to query sort\n$sortSpecMap")</ID>
    <ID>MaxLineLength:Reaction.kt$*</ID>
    <ID>MaxLineLength:ReactionDao.kt$ReactionDao$@Query("SELECT * FROM stream_chat_reaction WHERE stream_chat_reaction.type = :reactionType AND stream_chat_reaction.messageid = :messageId AND userId = :userId")</ID>
    <ID>MaxLineLength:RepositoryFacade.kt$RepositoryFacade.Companion$requireNotNull(userRepository.selectUser(userId)) { "User with the userId: `$userId` has not been found" }</ID>
    <ID>MaxLineLength:SendMessageInterceptorImpl.kt$SendMessageInterceptorImpl$// We enqueue attachments upload here if user is offline but an error is returned so message is not sent right away.</ID>
    <ID>MaxLineLength:SendMessageInterceptorImpl.kt$SendMessageInterceptorImpl$Result(ChatError("Chat is offline, there is no pending attachments to upload in message with id ${message.id} and text ${message.text}"))</ID>
    <ID>MaxLineLength:SendMessageInterceptorImpl.kt$SendMessageInterceptorImpl$logger.logI("Chat is offline and there is no pending attachments to upload in message with ${message.id} and text ${message.text}")</ID>
    <ID>MaxLineLength:SendReactionErrorHandlerImpl.kt$SendReactionErrorHandlerImpl$*</ID>
    <ID>MaxLineLength:StreamOfflinePluginFactory.kt$StreamOfflinePluginFactory$* Creates the [OfflinePlugin] and initialized its dependencies. This method must be called after the user is set in the SDK.</ID>
    <ID>MaxLineLength:SyncManager.kt$SyncManager$*</ID>
    <ID>MaxLineLength:SyncManager.kt$SyncManager$* Handles connection recover in the SDK. This method will sync the data, retry failed entities, update channels data, etc.</ID>
    <ID>MaxLineLength:SyncManager.kt$SyncManager$logger.logI("Retried ${channels.size} channel entities, ${messages.size} messages and ${reactions.size} reaction entities")</ID>
    <ID>MaxLineLength:SyncManager.kt$SyncManager$logger.logI("recovery called: recoverAll: $recoverAll, online: $online retrying $queriesToRetry queries and ${cids.size} channels")</ID>
    <ID>MaxLineLength:SyncManager.kt$SyncManager$logger.logI("storeStateForChannels stored ${channelsResponse.size} channels, ${configs.size} configs, ${users.size} users and ${messages.size} messages")</ID>
    <ID>MaxLineLength:TestDataHelper.kt$TestDataHelper$MemberRemovedEvent(EventType.MEMBER_REMOVED, Date(), member2.user, channel1.cid, channel1.type, channel1.id, member1)</ID>
    <ID>MaxLineLength:TestDataHelper.kt$TestDataHelper$checkNotNull(dotenv["STREAM_USER_1_TOKEN"]) { "Be sure to specify the STREAM_USER_1_TOKEN environment variable" }</ID>
    <ID>MaxLineLength:TestUtils.kt$val connectivityManager = getApplicationContext&lt;Context>().getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager</ID>
    <ID>MaxLineLength:ThreadMutableState.kt$ThreadMutableState$channelMutableState.messageList.map { messageList -> messageList.filter { it.id == parentId || it.parentId == parentId } }</ID>
    <ID>MaxLineLength:ThreadState.kt$ThreadState$/** The oldest message available in this thread state. It's null when we haven't loaded any messages in thread yet. */</ID>
    <ID>MaxLineLength:TypingEventListenerImpl.kt$TypingEventListenerImpl$*</ID>
    <ID>MaxLineLength:TypingEventListenerImpl.kt$TypingEventListenerImpl$else</ID>
    <ID>MaxLineLength:UploadAttachmentsNetworkType.kt$UploadAttachmentsNetworkType$* An enumeration of various network types used as a constraint in [io.getstream.chat.android.offline.internal.message.attachments.UploadAttachmentsAndroidWorker].</ID>
    <ID>MaxLineLength:UserEntity.kt$UserEntity$*</ID>
    <ID>NestedBlockDepth:CustomObjectFiltering.kt$@Suppress("UNCHECKED_CAST") internal fun &lt;T : CustomObject> FilterObject.filter(t: T): Boolean</ID>
    <ID>NestedBlockDepth:EventHandlerImpl.kt$EventHandlerImpl$private suspend fun updateOfflineStorageFromEvents(events: List&lt;ChatEvent>, isFromSync: Boolean)</ID>
    <ID>NestedBlockDepth:FilterObjectConverter.kt$private fun Map.Entry&lt;String, Any>.toFilterObject(): FilterObject</ID>
    <ID>NestedBlockDepth:UploadAttachmentsWorker.kt$UploadAttachmentsWorker$suspend fun uploadAttachmentsForMessage( channelType: String, channelId: String, messageId: String, ): Result&lt;Unit></ID>
    <ID>PrintStackTrace:UploadAttachmentsWorker.kt$UploadAttachmentsWorker$e</ID>
    <ID>ReturnCount:ChannelMarkReadHelper.kt$ChannelMarkReadHelper$ internal fun markChannelReadLocallyIfNeeded(channelType: String, channelId: String): Boolean</ID>
    <ID>ReturnCount:UploadAttachmentsWorker.kt$UploadAttachmentsWorker$suspend fun uploadAttachmentsForMessage( channelType: String, channelId: String, messageId: String, ): Result&lt;Unit></ID>
    <ID>SpreadOperator:FilterObjectConverter.kt$(*(this.value as List&lt;Map&lt;String, Any>>).map(Map&lt;String, Any>::toFilterObject).toTypedArray())</ID>
    <ID>SwallowedException:CustomObjectFiltering.kt$e: ClassCastException</ID>
    <ID>TooGenericExceptionCaught:ChatClient.kt$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:UploadAttachmentsWorker.kt$UploadAttachmentsWorker$e: Exception</ID>
    <ID>UnnecessaryAbstractClass:QueryChannelsDao.kt$QueryChannelsDao</ID>
    <ID>UnusedPrivateMember:EventHandlerImpl.kt$EventHandlerImpl$user: User</ID>
    <ID>UnusedPrivateMember:QueryChannelsSortTest.kt$QueryChannelsSortTest$testName: String</ID>
    <ID>UnusedPrivateMember:UserRepositoryTests.kt$UserRepositoryTests$private val currentUser: User = randomUser(id = "currentUserId")</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$/** Channel config data. */ internal val _channelConfig: MutableStateFlow&lt;Config> = MutableStateFlow(Config())</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _channelData = MutableStateFlow&lt;ChannelData?>(null)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _endOfNewerMessages = MutableStateFlow(false)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _endOfOlderMessages = MutableStateFlow(false)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _hidden = MutableStateFlow(false)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _loading = MutableStateFlow(false)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _loadingNewerMessages = MutableStateFlow(false)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _loadingOlderMessages = MutableStateFlow(false)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _members = MutableStateFlow&lt;Map&lt;String, Member>>(emptyMap())</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _membersCount = MutableStateFlow(0)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _messages = MutableStateFlow&lt;Map&lt;String, Message>>(emptyMap())</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _muted = MutableStateFlow(false)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _oldMessages = MutableStateFlow&lt;Map&lt;String, Message>>(emptyMap())</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _read = MutableStateFlow&lt;ChannelUserRead?>(null)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _reads = MutableStateFlow&lt;Map&lt;String, ChannelUserRead>>(emptyMap())</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _repliedMessage = MutableStateFlow&lt;Message?>(null)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _typing = MutableStateFlow&lt;Map&lt;String, ChatEvent>>(emptyMap())</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _unreadCount = MutableStateFlow(0)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _watcherCount = MutableStateFlow(0)</ID>
    <ID>VariableNaming:ChannelMutableState.kt$ChannelMutableState$internal val _watchers = MutableStateFlow&lt;Map&lt;String, User>>(emptyMap())</ID>
    <ID>VariableNaming:GlobalMutableState.kt$GlobalMutableState$internal val _banned = MutableStateFlow(false)</ID>
    <ID>VariableNaming:GlobalMutableState.kt$GlobalMutableState$internal val _channelMutes = MutableStateFlow&lt;List&lt;ChannelMute>>(emptyList())</ID>
    <ID>VariableNaming:GlobalMutableState.kt$GlobalMutableState$internal val _channelUnreadCount = MutableStateFlow(0)</ID>
    <ID>VariableNaming:GlobalMutableState.kt$GlobalMutableState$internal val _connectionState = MutableStateFlow(ConnectionState.OFFLINE)</ID>
    <ID>VariableNaming:GlobalMutableState.kt$GlobalMutableState$internal val _errorEvent = MutableStateFlow(Event(ChatError()))</ID>
    <ID>VariableNaming:GlobalMutableState.kt$GlobalMutableState$internal val _initialized = MutableStateFlow(false)</ID>
    <ID>VariableNaming:GlobalMutableState.kt$GlobalMutableState$internal val _mutedUsers = MutableStateFlow&lt;List&lt;Mute>>(emptyList())</ID>
    <ID>VariableNaming:GlobalMutableState.kt$GlobalMutableState$internal val _totalUnreadCount = MutableStateFlow(0)</ID>
    <ID>VariableNaming:GlobalMutableState.kt$GlobalMutableState$internal val _typingChannels = MutableStateFlow(TypingEvent("", emptyList()))</ID>
    <ID>VariableNaming:GlobalMutableState.kt$GlobalMutableState$internal val _user = MutableStateFlow&lt;User?>(null)</ID>
    <ID>VariableNaming:QueryChannelsMutableState.kt$QueryChannelsMutableState$internal val _channels = MutableStateFlow&lt;Map&lt;String, Channel>>(emptyMap())</ID>
    <ID>VariableNaming:QueryChannelsMutableState.kt$QueryChannelsMutableState$internal val _currentRequest = MutableStateFlow&lt;QueryChannelsRequest?>(null)</ID>
    <ID>VariableNaming:QueryChannelsMutableState.kt$QueryChannelsMutableState$internal val _endOfChannels = MutableStateFlow(false)</ID>
    <ID>VariableNaming:QueryChannelsMutableState.kt$QueryChannelsMutableState$internal val _loading = MutableStateFlow(false)</ID>
    <ID>VariableNaming:QueryChannelsMutableState.kt$QueryChannelsMutableState$internal val _loadingMore = MutableStateFlow(false)</ID>
    <ID>VariableNaming:QueryChannelsMutableState.kt$QueryChannelsMutableState$internal val _recoveryNeeded: MutableStateFlow&lt;Boolean> = MutableStateFlow(false)</ID>
    <ID>VariableNaming:ThreadMutableState.kt$ThreadMutableState$internal val _endOfOlderMessages = MutableStateFlow(false)</ID>
    <ID>VariableNaming:ThreadMutableState.kt$ThreadMutableState$internal val _loadingOlderMessages = MutableStateFlow(false)</ID>
    <ID>VariableNaming:ThreadMutableState.kt$ThreadMutableState$internal val _oldestInThread: MutableStateFlow&lt;Message?> = MutableStateFlow(null)</ID>
  </CurrentIssues>
</SmellBaseline>
